#from flask import Flask, request, jsonify
#from flask_cors import CORS
"""import torch
import torchvision
from torchvision import transforms
from PIL import Image
import io

#app = Flask(__name__)
#CORS(app)  # Enable CORS for cross-origin requests

# Load Model
model = torchvision.models.detection.fasterrcnn_resnet50_fpn(pretrained=False, num_classes=2)
model.load_state_dict(torch.load(r"C:\Users\keert\OneDrive\Desktop\global-wheat-detection\fasterrcnn_resnet50_epochUpdated.pth", map_location=torch.device('cpu')))
model.eval()

# Preprocess function
def preprocess_image(image):
    transform = transforms.Compose([transforms.ToTensor()])
    return transform(image).unsqueeze(0)
count=0
# Extract bounding boxes
def get_boxes(prediction, threshold=0.5):
    boxes = []
    count=0
    for box, score in zip(prediction[0]['boxes'], prediction[0]['scores']):
        if score > threshold:
            x1, y1, x2, y2 = map(int, box.tolist())
            boxes.append({"x1": x1, "y1": y1, "x2": x2, "y2": y2, "score": float(score)})
            count+=1
    if(count>=15):
        return boxes
    else:
        boxes=[]
        return boxes

model_path = r"C:\Users\keert\Downloads\image_source_classifier.h5"  # Path to the trained model


# Parameters
IMG_SIZE = (128, 128)

# Load the model
model_2 = load_model(model_path)

#label_map = {0: 'arvalis_1', 1: 'arvalis_2', 2: 'arvalis_3', 3: 'ethz_1', 4: 'inrae_1', 5: 'rres_1', 6: 'usask_1'}
label_map = {0: 'Post-flowering', 1: 'Filling', 2: 'Filling - Ripening', 3: 'Filling', 4: 'Filling - Ripening', 5: 'Filling - Ripening', 6: 'Filling - Ripening'}

@app.route("/spike-detection", methods=["POST"])
def predict():
    if "file" not in request.files:
        return jsonify({"error": "No file uploaded"}), 400

    file = request.files["file"]
    image = Image.open(io.BytesIO(file.read()))
    input_tensor = preprocess_image(image.convert("RGB"))
    img = image.resize(IMG_SIZE)
    img_array = np.array(img) / 255.0
    img_array = np.expand_dims(img_array, axis=0)
    with torch.no_grad():
        prediction = model(input_tensor)
        prediction_2=model_2(img_array)[0]
        predicted_label = label_map[np.argmax(prediction_2)]
    boxes = get_boxes(prediction)
    result = {
        "boxes": boxes,
        "development_stage": predicted_label
    }
    if(len(boxes)==0):
        result="Image Error"
    return jsonify(result)
    #return jsonify("Image Error")"""
